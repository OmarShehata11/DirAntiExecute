/*++

Module Name:

    MalwareAntiExecute.c

Abstract:

    The main module, in this one we will try to stop any EXECUTE  action for any binary that
    is under the "C:\Users\Omar Shehata\Desktop\MALWARES" path, simple as that.

Environment:

    Kernel mode

--*/

/*
FUTURE WORK:
        - Use the Stream context to avoid checking the same file many times.

*/

#include <fltKernel.h>
#include <dontuse.h>

// just disable some prefast warnings (the encoding of functoin pointers)..
#pragma prefast(disable:__WARNING_ENCODE_MEMBER_FUNCTION_POINTER, "Not valid for kernel mode drivers")


PFLT_FILTER gFilterHandle;
ULONG_PTR OperationStatusCtx = 1;

#define TARGET_DIR L"\\MALWARES\\"

#define DBG_TRACE_ROUTINES            0x00000001
#define DBG_TRACE_OPERATION_STATUS    0x00000002
#define DBG_MESSAGES_TO_USER    0x00000004



// Self added code, to just make the debug prints the the INFO and ERROR type of messages.
#define DEBUG_ERROR  0x01
#define DEBUG_INFO   0x02
#define DEBUG_MESSAGE 0x04

ULONG gTraceFlags = DEBUG_ERROR | DEBUG_INFO | DEBUG_MESSAGE;

// log the files only if the gTraceFlags flag is enabled.
#define DBG_PRINT( _dbgLevel, _string )          \
    (FlagOn(gTraceFlags,(_dbgLevel)) ?              \
        KdPrint (_string) :                          \
        ((int)0)) // the parentheses of the DbgPrint function is written with the _string parameter itself.

EXTERN_C_START

DRIVER_INITIALIZE DriverEntry;
NTSTATUS
DriverEntry(
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PUNICODE_STRING RegistryPath
);


NTSTATUS
MalwareAntiExecuteUnload(
    _In_ FLT_FILTER_UNLOAD_FLAGS Flags
);

FLT_PREOP_CALLBACK_STATUS
MalwareAntiExecutePreOperation(
    _Inout_ PFLT_CALLBACK_DATA Data,
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _Flt_CompletionContext_Outptr_ PVOID* CompletionContext
);

FLT_POSTOP_CALLBACK_STATUS
MalwareAntiExecutePostOperation(
    IN OUT PFLT_CALLBACK_DATA Data,
    IN PCFLT_RELATED_OBJECTS FltObjects,
    IN PVOID CompletionContext,
    IN FLT_POST_OPERATION_FLAGS Flags
);

NTSTATUS ZwQueryInformationProcess(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL
);

PFLT_FILE_NAME_INFORMATION MalwareAntiExecuteGetFileNameHelper(
    PFLT_CALLBACK_DATA Data
);

EXTERN_C_END

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#endif


//
//  operation registration
//

CONST FLT_OPERATION_REGISTRATION Callbacks[] = {

    { IRP_MJ_CREATE, 
      0,
      MalwareAntiExecutePreOperation,
      MalwareAntiExecutePostOperation},

    { IRP_MJ_OPERATION_END }
};

//
//  This defines what we want to filter with FltMgr
//

CONST FLT_REGISTRATION FilterRegistration = {

    sizeof(FLT_REGISTRATION),         //  Size
    FLT_REGISTRATION_VERSION,           //  Version
    0,                                  //  Flags

    NULL,                               //  Context
    Callbacks,                          //  Operation callbacks

    MalwareAntiExecuteUnload,                           //  MiniFilterUnload

    NULL,                    //  InstanceSetup
    NULL,            //  InstanceQueryTeardown
    NULL,            //  InstanceTeardownStart
    NULL,         //  InstanceTeardownComplete

    NULL,                               //  GenerateFileName
    NULL,                               //  GenerateDestinationFileName
    NULL                                //  NormalizeNameComponent

};



NTSTATUS
DriverEntry(
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PUNICODE_STRING RegistryPath
)
/*++

Routine Description:

    This is the initialization routine for this miniFilter driver.  This
    registers with FltMgr and initializes all global data structures.

Arguments:

    DriverObject - Pointer to driver object created by the system to
        represent this driver.

    RegistryPath - Unicode string identifying where the parameters for this
        driver are located in the registry.

Return Value:

    Routine can return non success error codes.

--*/
{
    NTSTATUS status;

    UNREFERENCED_PARAMETER(RegistryPath);

    DBG_PRINT(DBG_TRACE_ROUTINES,
        ("MalwareAntiExecute!DriverEntry: Entered\n"));

    //
    //  Register with FltMgr to tell it our callback routines
    //

    status = FltRegisterFilter(DriverObject,
        &FilterRegistration,
        &gFilterHandle);

    FLT_ASSERT(NT_SUCCESS(status));

    if (NT_SUCCESS(status)) {

        //
        //  Start filtering i/o
        //

        status = FltStartFiltering(gFilterHandle);

        if (!NT_SUCCESS(status)) {

            FltUnregisterFilter(gFilterHandle);
        }
    }

    return status;
}




NTSTATUS
MalwareAntiExecuteUnload(
    _In_ FLT_FILTER_UNLOAD_FLAGS Flags
)
/*++

Routine Description:

    This is the unload routine for this miniFilter driver. This is called
    when the minifilter is about to be unloaded. We can fail this unload
    request if this is not a mandatory unload indicated by the Flags
    parameter.

Arguments:

    Flags - Indicating if this is a mandatory unload.

Return Value:

    Returns STATUS_SUCCESS.

--*/
{
    UNREFERENCED_PARAMETER(Flags);

    PAGED_CODE();

    DBG_PRINT(DBG_TRACE_ROUTINES,
        ("MalwareAntiExecute!MalwareAntiExecuteUnload: Entered\n"));

    FltUnregisterFilter(gFilterHandle);

    return STATUS_SUCCESS;
}


FLT_PREOP_CALLBACK_STATUS
MalwareAntiExecutePreOperation(
    _Inout_ PFLT_CALLBACK_DATA Data,
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _Flt_CompletionContext_Outptr_ PVOID* CompletionContext
)
/*++

Routine Description:

    This routine is a pre-operation dispatch routine for this miniFilter.

    This is non-pageable because it could be called on the paging path

Arguments:

    Data - Pointer to the filter callbackData that is passed to us.

    FltObjects - Pointer to the FLT_RELATED_OBJECTS data structure containing
        opaque handles to this filter, instance, its associated volume and
        file object.

    CompletionContext - The context for the completion routine for this
        operation.

Return Value:

    The return value is the status of the operation.

--*/
{
    NTSTATUS status;
    PFLT_FILE_NAME_INFORMATION pFltNameInfo = NULL;
    ULONG PID;
    PUNICODE_STRING ProcessPath = NULL;
    size_t PoolSize = 300;
    PEPROCESS pEPROCESS;
    HANDLE hProcess;

    UNREFERENCED_PARAMETER(FltObjects);
    UNREFERENCED_PARAMETER(CompletionContext);

 //   DBG_PRINT(DBG_TRACE_ROUTINES,
 //     ("MalwareAntiExecute!MalwareAntiExecutePreOperation: Entered\n"));

    
    if (Data->RequestorMode == UserMode)
    {
        pFltNameInfo = MalwareAntiExecuteGetFileNameHelper(Data);
        if (pFltNameInfo == NULL)
        {
            DBG_PRINT(DBG_TRACE_OPERATION_STATUS,
                ("[-] ERROR : Couldn't get the file name for sorry.\n"));

            goto CleanUpLbl;

        }
        //DBG_PRINT(DBG_MESSAGES_TO_USER,
        //    ("A file that is accessed nowww, the name is : %wZ\n", pFltNameInfo->Name));

        if (wcsstr(pFltNameInfo->Name.Buffer, TARGET_DIR))
        {
            DBG_PRINT(DBG_MESSAGES_TO_USER,
                ("Catched a file access request under our dir. it's name : %wZ\n", pFltNameInfo->Name));

            if (Data->Iopb->Parameters.Create.SecurityContext->DesiredAccess & FILE_EXECUTE) // opens the file with this permission.
            {

                DBG_PRINT(DBG_MESSAGES_TO_USER,
                    ("Catched a file access request with EXECUTE PERMISSION.\n"));
                // Now we will try to get the process name:
                PID = FltGetRequestorProcessId(Data);

                if (PID == 0)
                {
                    DBG_PRINT(DBG_TRACE_OPERATION_STATUS, ("[-] ERROR: Couldn't resolve the process ID.\n"));
                    goto CleanUpLbl;
                }

                // I will try to get the process name with 2 ways using the same API (ZwQueryInformationProcess)

                // Method 1:
                ProcessPath = (PUNICODE_STRING)(ExAllocatePool(PagedPool, PoolSize));

                if (ProcessPath == NULL)
                {
                    DBG_PRINT(DBG_TRACE_OPERATION_STATUS,
                        ("[-] ERROR: Couldn't allocate space for process Name.\n"));

                    goto CleanUpLbl;
                }

                RtlZeroMemory(ProcessPath, PoolSize);

                status = ZwQueryInformationProcess(NtCurrentProcess(), ProcessImageFileName, ProcessPath,
                    PoolSize - sizeof(WCHAR), NULL);

                if (!NT_SUCCESS(status))
                {
                    // Now try the other method
                    pEPROCESS = PsGetThreadProcess(Data->Thread);

                    status = ObOpenObjectByPointer(pEPROCESS, OBJ_KERNEL_HANDLE, NULL, 0, NULL, KernelMode, &hProcess);

                    if (!NT_SUCCESS(status))
                    {
                        DBG_PRINT(DBG_TRACE_OPERATION_STATUS, ("[-] ERROR: Couldn't open a handle to the process.\n"));
                        goto CleanUpLbl;
                    }


                    status = ZwQueryInformationProcess(hProcess, ProcessImageFileName, ProcessPath,
                        PoolSize - sizeof(WCHAR), NULL);

                    if (!NT_SUCCESS(status))
                    {
                        DBG_PRINT(DBG_TRACE_OPERATION_STATUS, 
                            ("[-] ERROR: Couldn't get the name of the file using the second method.\n"));
                        
                        goto CleanUpLbl;
                    }

                }

                // Now we have the process Name..

                DBG_PRINT(DBG_MESSAGES_TO_USER,
                    ("[+] The Process %wZ Wants to execute the file %wZ, but aborted.\n",
                        *ProcessPath,
                        pFltNameInfo->Name));

                // now the last part, cancel the request...
                // we should do so in the post-create callback routine..

                if (pFltNameInfo != NULL)
                    FltReleaseFileNameInformation(pFltNameInfo);

                if (ProcessPath != NULL)
                    ExFreePool(ProcessPath);

                return FLT_PREOP_SUCCESS_WITH_CALLBACK;
            }
        }

    }
   

CleanUpLbl:
    if (pFltNameInfo != NULL)
        FltReleaseFileNameInformation(pFltNameInfo);

    if (ProcessPath != NULL)
        ExFreePool(ProcessPath);

    return FLT_PREOP_SUCCESS_NO_CALLBACK;
}



//
// SOME HELPER FUNCTIONS
//


PFLT_FILE_NAME_INFORMATION MalwareAntiExecuteGetFileNameHelper(PFLT_CALLBACK_DATA Data)
{

    /* ROUTINE EXPLAINATION:
        - this routine retrive the info about the object file name represented in FLT_FILE_NAME_INFORMATION.

        PARAMETERS:
            -Data: to get the file object from it.

        RETURN:
            - pointer to FLT_FILE_NAME_INFORMATION: if it could find one (whether it's normalized or opened file name.
            - NULL: if it couldn't find one.
    */
    
    /*
    DBG_PRINT(DBG_TRACE_ROUTINES,
        ("MalwareAntiExecute!MalwareAntiExecuteGetFileNameHelper: Entered\n"));
        */


    NTSTATUS status;
    PFLT_FILE_NAME_INFORMATION pFltNameInfo = NULL;

    status = FltGetFileNameInformation(Data, FLT_FILE_NAME_QUERY_ALWAYS_ALLOW_CACHE_LOOKUP | FLT_FILE_NAME_NORMALIZED, &pFltNameInfo);

    /*
    WE ARE GOING TO FIRST GET THE NORMALIZED FILE NAME, IF IT FAILED, THEN WE WILL GET THE OPENED FILE NAME
    (BY OF COURSE CHANGING THE FLAGS USED)
    */

    //failed to get the normalized name, now try to get the open name : 
    if (!NT_SUCCESS(status))
    {
        status = FltGetFileNameInformation(Data, FLT_FILE_NAME_QUERY_ALWAYS_ALLOW_CACHE_LOOKUP | FLT_FILE_NAME_OPENED, &pFltNameInfo);

        if (NT_SUCCESS(status))
            goto FileNameSuccLabel;

        goto CleanUpFileNameInfo;
    }

FileNameSuccLabel: // the normal flow will reach this anyway if the first call is ok. 
    status = FltParseFileNameInformation(pFltNameInfo);
    if (NT_SUCCESS(status))
        return pFltNameInfo; // return the normalized name
    

 // SOME CLEANUP
CleanUpFileNameInfo: 
    if (pFltNameInfo != NULL)
        FltReleaseFileNameInformation(pFltNameInfo);

    return NULL;
}


FLT_POSTOP_CALLBACK_STATUS
MalwareAntiExecutePostOperation(
    IN OUT PFLT_CALLBACK_DATA Data,
    IN PCFLT_RELATED_OBJECTS FltObjects,
    IN PVOID CompletionContext,
    IN FLT_POST_OPERATION_FLAGS Flags
)
{

    DBG_PRINT(DBG_MESSAGES_TO_USER,
        ("Entering %s.\n", __FUNCTION__));

    // now just fail the request.
    FltCancelFileOpen(FltObjects->Instance, FltObjects->FileObject);

    Data->IoStatus.Status = STATUS_ACCESS_DENIED;
    Data->IoStatus.Information = 0;

    return FLT_POSTOP_FINISHED_PROCESSING;
}